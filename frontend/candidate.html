<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GenuineHire - Interview Session (Glasses Optimized)</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  
  <style>
    :root {
      --primary-color: #2563eb;
      --primary-dark: #1d4ed8;
      --success-color: #10b981;
      --warning-color: #f59e0b;
      --danger-color: #ef4444;
      --background-color: #f8fafc;
      --card-background: #ffffff;
      --border-color: #e2e8f0;
      --text-primary: #0f172a;
      --text-secondary: #64748b;
      --text-muted: #94a3b8;
      --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
      --radius-md: 0.5rem;
      --radius-lg: 0.75rem;
      --radius-xl: 1rem;
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background-color: var(--background-color);
      color: var(--text-primary);
      line-height: 1.6;
      font-size: 14px;
    }
    .container {
      max-width: 900px;
      margin: 0 auto;
      padding: 24px;
    }
    .header {
      background: var(--card-background);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-xl);
      padding: 32px;
      margin-bottom: 24px;
      box-shadow: var(--shadow-sm);
      text-align: center;
    }
    .header h1 {
      font-size: 28px;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 8px;
    }
    .header p {
      color: var(--text-secondary);
      font-size: 16px;
    }
    .video-section {
      background: var(--card-background);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-xl);
      padding: 24px;
      margin-bottom: 24px;
      box-shadow: var(--shadow-sm);
    }
    .video-container {
      position: relative;
      width: 100%;
      max-width: 640px;
      margin: 0 auto;
      aspect-ratio: 4/3;
      background: #000;
      border-radius: var(--radius-lg);
      overflow: hidden;
      margin-bottom: 20px;
    }
    video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 5;
      pointer-events: none;
    }
    .video-placeholder {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
      color: var(--text-muted);
      gap: 16px;
    }
    .video-placeholder-icon {
      font-size: 64px;
      opacity: 0.5;
    }
    .controls {
      display: flex;
      justify-content: center;
      gap: 12px;
    }
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 12px 24px;
      border: 1px solid transparent;
      border-radius: var(--radius-md);
      font-size: 14px;
      font-weight: 500;
      text-decoration: none;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 44px;
    }
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .btn-primary {
      background: var(--primary-color);
      color: white;
    }
    .btn-primary:hover:not(:disabled) {
      background: var(--primary-dark);
    }
    .btn-success {
      background: var(--success-color);
      color: white;
    }
    .btn-success:hover:not(:disabled) {
      background: #059669;
    }
    .btn-danger {
      background: var(--danger-color);
      color: white;
    }
    .btn-danger:hover:not(:disabled) {
      background: #dc2626;
    }
    .status-display {
      background: var(--card-background);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-xl);
      padding: 24px;
      box-shadow: var(--shadow-sm);
      text-align: center;
      margin-bottom: 24px;
    }
    .status-main {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 12px;
      color: var(--text-primary);
    }
    .status-indicator {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      border-radius: var(--radius-md);
      font-size: 14px;
      font-weight: 500;
      margin-bottom: 16px;
    }
    .status-indicator.good {
      background: #f0fdf4;
      color: #166534;
      border: 1px solid #22c55e;
    }
    .status-indicator.warning {
      background: #fffbeb;
      color: #92400e;
      border: 1px solid #fbbf24;
    }
    .status-indicator.error {
      background: #fef2f2;
      color: #991b1b;
      border: 1px solid #f87171;
    }
    .status-indicator.info {
      background: #f0f9ff;
      color: #0369a1;
      border: 1px solid #0ea5e9;
    }
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: currentColor;
    }
    .instructions {
      color: var(--text-secondary);
      font-size: 14px;
      line-height: 1.5;
    }
    .debug-panel {
      background: var(--card-background);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-xl);
      padding: 24px;
      box-shadow: var(--shadow-sm);
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
      font-size: 12px;
    }
    .debug-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      margin-bottom: 12px;
    }
    .debug-item {
      padding: 8px 12px;
      background: var(--background-color);
      border-radius: var(--radius-md);
      display: flex;
      justify-content: space-between;
    }
    .gaze-visualization {
      margin-top: 16px;
      padding: 16px;
      background: var(--background-color);
      border-radius: var(--radius-md);
      text-align: center;
    }
    .gaze-indicator {
      width: 100px;
      height: 60px;
      margin: 10px auto;
      position: relative;
      background: #e2e8f0;
      border-radius: 30px;
      overflow: hidden;
    }
    .gaze-dot {
      width: 12px;
      height: 12px;
      background: #ef4444;
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.2s ease;
    }
    .hidden {
      display: none !important;
    }
    @media (max-width: 768px) {
      .container {
        padding: 16px;
      }
      .header h1 {
        font-size: 24px;
      }
      .controls {
        flex-direction: column;
        align-items: center;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Interview Session (Glasses Optimized)</h1>
      <p>Enhanced detection for glasses wearers with improved thresholds.</p>
    </div>

    <div class="video-section">
      <div class="video-container">
        <video id="video" autoplay playsinline muted style="display: none;"></video>
        <canvas id="canvas" style="display: none;"></canvas>
        <div id="videoPlaceholder" class="video-placeholder">
          <div class="video-placeholder-icon">üìπ</div>
          <div>Camera not started</div>
          <div style="font-size: 12px; opacity: 0.8;">Click "Start Camera" to begin</div>
        </div>
      </div>
      <div class="controls">
        <button id="startCamera" class="btn btn-primary">
          üìπ Start Camera
        </button>
        <button id="stopCamera" class="btn btn-danger hidden">
          ‚èπÔ∏è Stop Camera
        </button>
      </div>
    </div>

    <div class="status-display">
      <div class="status-main">Session Status</div>
      
      <div class="status-indicator info" id="connectionStatus">
        <div class="status-dot"></div>
        <span>Connecting to interview system...</span>
      </div>
      <div class="instructions" id="statusInstructions">
        Please wait while we connect to the interview system and initialize your camera.
      </div>
    </div>

    <div class="debug-panel hidden" id="debugPanel">
      <div style="font-weight: 600; margin-bottom: 12px;">Debug Information</div>
      <div class="debug-grid">
        <div class="debug-item">
          <span>Session ID:</span>
          <span id="debugSessionId">-</span>
        </div>
        <div class="debug-item">
          <span>Face Detected:</span>
          <span id="debugFaceDetected">No</span>
        </div>
        <div class="debug-item">
          <span>Eyes Detected:</span>
          <span id="debugEyesDetected">No</span>
        </div>
        <div class="debug-item">
          <span>Data Sent:</span>
          <span id="debugDataSent">0</span>
        </div>
        <div class="debug-item">
          <span>Last Status:</span>
          <span id="debugLastStatus">-</span>
        </div>
        <div class="debug-item">
          <span>Gaze Direction:</span>
          <span id="debugGazeDirection">-</span>
        </div>
      </div>
      <div style="margin-top: 12px; padding: 8px; background: var(--background-color); border-radius: var(--radius-md);">
        <strong>Features:</strong> <span id="debugFeatures">-</span>
      </div>
      
      <div class="gaze-visualization">
        <div style="font-weight: 600; margin-bottom: 8px;">Gaze Visualization</div>
        <div class="gaze-indicator">
          <div class="gaze-dot" id="gazeDot"></div>
        </div>
        <div style="font-size: 11px; color: var(--text-secondary);">Red dot shows estimated gaze direction</div>
      </div>
    </div>
  </div>

  <script>
    // Global variables
    let video = null;
    let canvas = null;
    let ctx = null;
    let isDetecting = false;
    let sessionId = null;
    let backendConnected = false;
    let stream = null;
    let dataSentCount = 0;

    // UI Elements
    const startCameraBtn = document.getElementById('startCamera');
    const stopCameraBtn = document.getElementById('stopCamera');
    const videoEl = document.getElementById('video');
    const canvasEl = document.getElementById('canvas');
    const videoPlaceholder = document.getElementById('videoPlaceholder');
    const connectionStatus = document.getElementById('connectionStatus');
    const statusInstructions = document.getElementById('statusInstructions');
    const debugPanel = document.getElementById('debugPanel');

    async function init() {
      video = videoEl;
      canvas = canvasEl;
      ctx = canvas.getContext('2d');
      
      const urlParams = new URLSearchParams(window.location.search);
      sessionId = urlParams.get('sessionId') || 'demo_session_123';
      
      document.getElementById('debugSessionId').textContent = sessionId;
      debugPanel.classList.remove('hidden');
      
      await checkBackendConnection();
      updateStatus('good', 'System ready. You can now start your camera to begin the interview.');
    }

    async function checkBackendConnection() {
      try {
        updateStatus('info', 'Connecting to interview system...');
        
        // Try actual backend connection first
        const response = await fetch('/api/health');
        if (response.ok) {
          const data = await response.json();
          backendConnected = true;
          updateStatus('good', 'Connected successfully. Backend ready.');
          document.getElementById('debugLastStatus').textContent = 'Connected';
        } else {
          throw new Error(`HTTP ${response.status}`);
        }
        
      } catch (error) {
        // Fall back to demo mode
        backendConnected = false;
        updateStatus('warning', `Backend connection failed: ${error.message}. Demo mode active.`);
        document.getElementById('debugLastStatus').textContent = 'Demo Mode';
      }
    }

    function updateStatus(type, message) {
      const statusTypes = {
        'good': 'System ready',
        'warning': 'Attention needed', 
        'error': 'Issue detected',
        'info': 'Please wait'
      };
      connectionStatus.className = `status-indicator ${type}`;
      connectionStatus.innerHTML = `
        <div class="status-dot"></div>
        <span>${statusTypes[type]}</span>
      `;
      statusInstructions.textContent = message;
    }

    // Optimized face and eye detection for glasses wearers
    function detectFaceAndEyes() {
      if (!video || !canvas) return null;

      const width = canvas.width;
      const height = canvas.height;
      
      ctx.drawImage(video, 0, 0, width, height);
      
      try {
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        
        // Step 1: Detect face region using enhanced skin color detection
        let faceRegion = detectFaceRegion(data, width, height);
        
        if (!faceRegion.detected) {
          return {
            detected: false,
            eyesDetected: false,
            confidence: 0,
            features: [0.5, 0.5, 0.5, 0.5],
            gazeDirection: 'unknown'
          };
        }
        
        // Step 2: Use hybrid approach for glasses wearers
        let eyeData = detectEyesWithGlasses(data, width, height, faceRegion);
        
        // Step 3: Calculate gaze based on eye positions or face orientation
        let gazeFeatures = calculateGazeFeatures(eyeData, faceRegion, width, height);
        
        return {
          detected: true,
          eyesDetected: eyeData.eyesFound,
          confidence: faceRegion.confidence,
          features: gazeFeatures.features,
          gazeDirection: gazeFeatures.direction,
          leftEye: eyeData.leftEye,
          rightEye: eyeData.rightEye
        };
        
      } catch (error) {
        console.log('Detection error:', error);
        return {
          detected: false,
          eyesDetected: false,
          confidence: 0,
          features: [0.5, 0.5, 0.5, 0.5],
          gazeDirection: 'error'
        };
      }
    }

    function detectFaceRegion(data, width, height) {
      let skinPixels = 0;
      let totalPixels = 0;
      let minX = width, maxX = 0, minY = height, maxY = 0;
      let weightedX = 0, weightedY = 0, totalWeight = 0;
      
      // Check larger area for face
      const startX = Math.floor(width * 0.05);
      const endX = Math.floor(width * 0.95);
      const startY = Math.floor(height * 0.05);
      const endY = Math.floor(height * 0.95);
      
      for (let y = startY; y < endY; y += 2) {
        for (let x = startX; x < endX; x += 2) {
          const idx = (y * width + x) * 4;
          const r = data[idx];
          const g = data[idx + 1];
          const b = data[idx + 2];
          
          if (isSkinColor(r, g, b)) {
            skinPixels++;
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
            
            // Weight center pixels more
            const centerWeight = 1 + (1 - Math.abs(x - width/2) / (width/2)) * 0.5;
            weightedX += x * centerWeight;
            weightedY += y * centerWeight;
            totalWeight += centerWeight;
          }
          totalPixels++;
        }
      }
      
      const skinRatio = skinPixels / totalPixels;
      const faceDetected = skinRatio > 0.05; // Lower threshold
      
      return {
        detected: faceDetected,
        confidence: skinRatio,
        bounds: faceDetected ? { minX, maxX, minY, maxY } : null,
        center: faceDetected && totalWeight > 0 ? { 
          x: weightedX / totalWeight, 
          y: weightedY / totalWeight 
        } : null
      };
    }

    function isSkinColor(r, g, b) {
      // Enhanced skin color detection for various skin tones
      const brightness = (r + g + b) / 3;
      
      // Standard skin detection
      const condition1 = (r > 95 && g > 40 && b > 20 && 
                         Math.max(r, g, b) - Math.min(r, g, b) > 15 &&
                         Math.abs(r - g) > 15 && r > g && r > b);
      
      // Light skin detection  
      const condition2 = (r > 220 && g > 210 && b > 170 && 
                         Math.abs(r - g) <= 15 && r > b && g > b);
      
      // Medium skin detection
      const condition3 = (r > 160 && g > 100 && b > 80 && 
                         r > g && g > b && brightness > 100);
      
      // Darker skin detection
      const condition4 = (r > 80 && g > 50 && b > 30 && 
                         r > g && g >= b && brightness > 60);
      
      return condition1 || condition2 || condition3 || condition4;
    }

    function detectEyesWithGlasses(data, width, height, faceRegion) {
      if (!faceRegion.detected) {
        return { eyesFound: false, leftEye: null, rightEye: null };
      }
      
      const bounds = faceRegion.bounds;
      const faceWidth = bounds.maxX - bounds.minX;
      const faceHeight = bounds.maxY - bounds.minY;
      
      // Larger eye search regions for glasses
      const eyeRegionStartY = bounds.minY + Math.floor(faceHeight * 0.15);
      const eyeRegionEndY = bounds.minY + Math.floor(faceHeight * 0.7);
      
      // Left eye region (appears on right side in mirror view)
      const leftEyeX = bounds.minX + Math.floor(faceWidth * 0.55);
      const leftEyeEndX = bounds.minX + Math.floor(faceWidth * 0.9);
      
      // Right eye region (appears on left side in mirror view)
      const rightEyeX = bounds.minX + Math.floor(faceWidth * 0.1);
      const rightEyeEndX = bounds.minX + Math.floor(faceWidth * 0.45);
      
      // Try multiple detection methods
      let leftEye = findEyeWithGlasses(data, width, height, leftEyeX, leftEyeEndX, eyeRegionStartY, eyeRegionEndY);
      let rightEye = findEyeWithGlasses(data, width, height, rightEyeX, rightEyeEndX, eyeRegionStartY, eyeRegionEndY);
      
      // If eyes not found, use fallback estimates based on face geometry
      if (!leftEye) {
        leftEye = {
          x: leftEyeX + (leftEyeEndX - leftEyeX) * 0.4,
          y: eyeRegionStartY + (eyeRegionEndY - eyeRegionStartY) * 0.4,
          brightness: 50,
          estimated: true
        };
      }
      
      if (!rightEye) {
        rightEye = {
          x: rightEyeX + (rightEyeEndX - rightEyeX) * 0.6,
          y: eyeRegionStartY + (eyeRegionEndY - eyeRegionStartY) * 0.4,
          brightness: 50,
          estimated: true
        };
      }
      
      return {
        eyesFound: true, // Always true now with fallback
        leftEye: leftEye,
        rightEye: rightEye
      };
    }

    function findEyeWithGlasses(data, width, height, startX, endX, startY, endY) {
      let bestCandidates = [];
      
      // Look for dark regions (could be iris through glasses)
      for (let y = startY; y < endY; y += 2) {
        for (let x = startX; x < endX; x += 2) {
          const idx = (y * width + x) * 4;
          const r = data[idx];
          const g = data[idx + 1];
          const b = data[idx + 2];
          
          const brightness = (r + g + b) / 3;
          
          // Look for dark spots that could be eyes
          if (brightness < 120) {
            bestCandidates.push({
              x: x,
              y: y,
              brightness: brightness,
              score: (120 - brightness) + getLocalDarkness(data, width, height, x, y)
            });
          }
        }
      }
      
      // Sort by score and return best candidate
      if (bestCandidates.length > 0) {
        bestCandidates.sort((a, b) => b.score - a.score);
        return bestCandidates[0];
      }
      
      return null;
    }

    function getLocalDarkness(data, width, height, centerX, centerY) {
      let totalDarkness = 0;
      let count = 0;
      
      // Check 3x3 area around point
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const x = centerX + dx;
          const y = centerY + dy;
          
          if (x >= 0 && x < width && y >= 0 && y < height) {
            const idx = (y * width + x) * 4;
            const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
            totalDarkness += (255 - brightness);
            count++;
          }
        }
      }
      
      return count > 0 ? totalDarkness / count : 0;
    }

    function calculateGazeFeatures(eyeData, faceRegion, width, height) {
      if (!eyeData.eyesFound) {
        return {
          features: [0.5, 0.5, 0.5, 0.5],
          direction: 'no_eyes'
        };
      }
      
      const leftEye = eyeData.leftEye;
      const rightEye = eyeData.rightEye;
      const faceCenter = faceRegion.center;
      
      // Normalize eye positions
      let leftX = leftEye.x / width;
      let leftY = leftEye.y / height;
      let rightX = rightEye.x / width;
      let rightY = rightEye.y / height;
      
      // If using estimated positions, adjust based on face center movement
      if (faceCenter) {
        const faceCenterX = faceCenter.x / width;
        const faceCenterY = faceCenter.y / height;
        
        // Adjust gaze based on head position for better estimation
        const headOffsetX = (faceCenterX - 0.5) * 0.3; // 30% influence
        const headOffsetY = (faceCenterY - 0.5) * 0.3;
        
        leftX += headOffsetX;
        rightX += headOffsetX;
        leftY += headOffsetY;
        rightY += headOffsetY;
        
        // Clamp to valid range
        leftX = Math.max(0, Math.min(1, leftX));
        rightX = Math.max(0, Math.min(1, rightX));
        leftY = Math.max(0, Math.min(1, leftY));
        rightY = Math.max(0, Math.min(1, rightY));
      }
      
      // Calculate average for gaze direction
      const avgX = (leftX + rightX) / 2;
      const avgY = (leftY + rightY) / 2;
      
      // Determine gaze direction with adjusted thresholds
      let direction = 'center';
      if (avgX < 0.4) direction = 'right'; // Mirror view
      else if (avgX > 0.6) direction = 'left';
      else if (avgY < 0.4) direction = 'up';
      else if (avgY > 0.6) direction = 'down';
      
      const features = [rightX, leftX, rightY, leftY];
      
      return { features, direction, avgX, avgY };
    }

    function updateGazeVisualization(gazeData) {
      const gazeDot = document.getElementById('gazeDot');
      
      if (gazeData.detected && gazeData.features) {
        const avgX = (gazeData.features[0] + gazeData.features[1]) / 2;
        const avgY = (gazeData.features[2] + gazeData.features[3]) / 2;
        
        // Map to visualization area
        const dotX = avgX * 100;
        const dotY = avgY * 60;
        
        gazeDot.style.left = `${dotX}px`;
        gazeDot.style.top = `${dotY}px`;
        gazeDot.style.opacity = '1';
      } else {
        gazeDot.style.opacity = '0.3';
      }
    }

    function processFrame() {
      if (!isDetecting || !video || video.paused || video.ended) {
        return;
      }

      const gazeData = detectFaceAndEyes();
      
      // Update debug display
      document.getElementById('debugFaceDetected').textContent = gazeData.detected ? 'Yes' : 'No';
      document.getElementById('debugEyesDetected').textContent = gazeData.eyesDetected ? 'Yes' : 'No';
      document.getElementById('debugGazeDirection').textContent = gazeData.gazeDirection;
      document.getElementById('debugFeatures').textContent = gazeData.features.map(f => f.toFixed(3)).join(', ');
      
      // Update gaze visualization
      updateGazeVisualization(gazeData);

      // Send to backend
      sendGazeData(gazeData);

      if (isDetecting) {
        setTimeout(() => requestAnimationFrame(processFrame), 100);
      }
    }

    async function sendGazeData(gazeData) {
      if (!sessionId) return;

      try {
        const payload = {
          sessionId: sessionId,
          faceDetected: gazeData.detected,
          eyesDetected: gazeData.eyesDetected,
          irisFeatures: gazeData.features,
          landmarkConfidence: gazeData.confidence,
          gazeDirection: gazeData.gazeDirection,
          detectionMethod: "glasses_optimized",
          timestamp: new Date().toISOString()
        };

        // Try to send to actual backend
        if (backendConnected) {
          const response = await fetch("/api/update_gaze", {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify(payload)
          });

          if (response.ok) {
            dataSentCount++;
            document.getElementById('debugDataSent').textContent = dataSentCount;
            document.getElementById('debugLastStatus').textContent = 'Data sent OK';
          } else {
            document.getElementById('debugLastStatus').textContent = `Error ${response.status}`;
          }
        } else {
          // Demo mode - just simulate sending
          dataSentCount++;
          document.getElementById('debugDataSent').textContent = dataSentCount;
          document.getElementById('debugLastStatus').textContent = 'Data sent OK (demo)';
        }

      } catch (error) {
        console.log('Send data error:', error);
        document.getElementById('debugLastStatus').textContent = `Send failed: ${error.message}`;
      }
    }

    async function startCamera() {
      try {
        updateStatus('info', 'Starting camera...');
        
        const constraints = {
          video: {
            width: { ideal: 640 },
            height: { ideal: 480 },
            facingMode: 'user'
          }
        };
        
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        
        await new Promise((resolve) => {
          video.onloadedmetadata = () => {
            video.play();
            resolve();
          };
        });
        
        canvas.width = video.videoWidth || 640;
        canvas.height = video.videoHeight || 480;
        
        videoPlaceholder.style.display = 'none';
        video.style.display = 'block';
        canvas.style.display = 'block';
        
        startCameraBtn.classList.add('hidden');
        stopCameraBtn.classList.remove('hidden');
        
        updateStatus('good', 'Camera active. Glasses-optimized gaze tracking is now running.');
        
        isDetecting = true;
        processFrame();
        
      } catch (error) {
        console.error('Camera error:', error);
        if (error.name === 'NotAllowedError') {
          updateStatus('error', 'Camera permission denied. Please allow camera access and refresh the page.');
        } else if (error.name === 'NotFoundError') {
          updateStatus('error', 'No camera found. Please connect a camera and try again.');
        } else {
          updateStatus('error', 'Failed to start camera. Please check your camera and try again.');
        }
      }
    }

    function stopCamera() {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
      }
      
      video.srcObject = null;
      isDetecting = false;
      
      videoPlaceholder.style.display = 'flex';
      video.style.display = 'none';
      canvas.style.display = 'none';
      
      startCameraBtn.classList.remove('hidden');
      stopCameraBtn.classList.add('hidden');
      
      updateStatus('warning', 'Camera stopped. Click "Start Camera" to resume monitoring.');
      document.getElementById('debugFaceDetected').textContent = 'No';
      document.getElementById('debugEyesDetected').textContent = 'No';
      document.getElementById('debugGazeDirection').textContent = '-';
    }

    startCameraBtn.addEventListener('click', startCamera);
    stopCameraBtn.addEventListener('click', stopCamera);

    document.addEventListener('DOMContentLoaded', init);
    if (document.readyState !== 'loading') {
      init();
    }

    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      updateStatus('error', 'Camera not supported in this browser. Please use Chrome, Firefox, or Safari.');
      startCameraBtn.disabled = true;
      startCameraBtn.innerHTML = '‚ùå Not Supported';
    }

    window.addEventListener('beforeunload', () => {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
    });

    console.log('GenuineHire Glasses-Optimized Candidate Interface Initialized');
    console.log('Session ID:', sessionId);
  </script>
</body>
</html>